This document will answer the framework on which the system calls and driver
calls will work. It also has a section on how the loader will load different
files into memory and initialize them.

The OS will have to assume the LONG mode of operation, because SMALL mode is a
special case of the LONG mode. The drivers and the kernel itself will all work
with long mode - So writing parts in C would be difficult.

Note:
* LONG mode means CS = DS <> SS. 
* SMALL mode means CS = DS = SS. DS must always be same as CS.

System language arguments:
	Arguments of a system call is passed via registers.

Standard system call would look something like this:

    ------------------------------------------
	1. Application program:
    ------------------------------------------
	   ; We cal call any OS system call, and not need to mention the DS
	   ; explicitly. It will be handled by the OS.	
		MOV AX, 1
		MOV BX, filename
		MOV CX, OPEN
		INT 0x40		
	
	filename: DB 'diary.txt',0
	OPEN: EQU 0x1

    ------------------------------------------
	2. Operating system
    ------------------------------------------
		; We make DS = CS (as per our convention), however we preserve it into
		; the ES register (here in this example), and restored before 
		; returning.
		--------------------------------------
		a. Dispatcher
		--------------------------------------
			mov es, ds
			mov ds, cs
			call [jumptable + 3 * ax] 	; each of the entry is 3 bytes
			mov ds, es
			iret

		--------------------------------------
		b. Jump table
		--------------------------------------
			jmp near open_file

		--------------------------------------
		c. 'open_file' function
		--------------------------------------
			; When calling driver method, the application DS must be provided
			; explicitly (here pushed to stack.)
			; Note that the stack is the same as the application program, as it
			; was never changed.
			open_file:
				call isspecialfile				
				je	open_special_file

				; Arguments for the OPEN function
				push es
				push bx		
				push cx
				call [settings + DEFAULT_FILE_SYSTEM + OPEN_METHOD]
				ret 		; return value from the driver is in AX register.

    ------------------------------------------
	3. File system driver
    ------------------------------------------
	   ; The stack will have the arguments, and points will come with the
	   ; segment registers as well. ES register is not assumed to have the
	   ; value of application program DS, in the driver relm.
	   ; The driver need to change the DS, as it was already changed by the OS
	   ; in the dispatcher.
		open:
			call findfile
			call openfile
			ret
			
Below is an overview of the structure of the executable and driver files.
Each of the executable and driver files have an entry point. The arguments to
this program will be in stack.

Drivers and application programs will begin at an offset of 0x64.
The arguments to the program will be in the stack. The 100 bytes at the
beginning is reserved for future use.

----------------------------------------------------------------------
Loading of drivers by the laoder:
----------------------------------------------------------------------
	; call to the _init method of a loaded driver program.
	; It is assumed that the data segemnt switching is already done.

	lea ax, [position + _START_OFFSET]	; For DOS _START_OFFSET is 0x100
										; Ours will be 0x64
	push argument_n
	push argument_n-1
	push n
	call near ax

	; The '_START_OFFSET' constant - every program will be 
	; loaded at a fixed offset and the _init function must start from the first
	; instruction in the program. Thus _init is at offset 0 in the process.

	; As SS <> DS not all C compilers can be used to build drivers.
	; But if it be done, the decleration for _init would look like this.
	void _init(int16 argument_count, int16 arguments[]);

	void (*init_ptr)(int8,int16*);
	init_ptr = (void (*)(int8, int16*))(driver_address + _START_OFFSET);
	init_ptr(0,NULL);

	; In the above code, 'driver_address' is the offset at which driver is
	; loaded, and _START_OFFSET is the fixed offset at which the entry point 
	; _init is supposed to be in the program.

Why is the meaning of the values passed to the program?
	The arguments are pushed on to the stack with the last element pushed
	should be the count of the arguments that were pushed. What meaning the
	arguments hold will depend on the program. Normally drivers will not need
	any arguments to be passed to it. But it is there.
	As you can imagine this model will also work with application programs to
	pass startup parametes in the stack.

---------------------------------------------------------------------------
General pseudocode for loading programs and executing the _init function:
---------------------------------------------------------------------------
	; Each of the programs to load will be loaded at segment 0x800,
	; just after the loader. 

	char *programs_to_load[] =
	{"debug.drv","mos","kdb.drv","con.drv","kdb.drv", NULL};

	int seg = DS;
	int OFFSET = 0x64;
	int position = 0x400; 
	for(int i = 0; 
				(filename = programs_to_load[i]) != NULL; i++)
	{	
		; Loads the file at DS:position + OFFSET;
		; Thus the first file is loaded at 0x800:0x464

		size = laodfile(filename, DS, position + OFFSET);
#asm
		; call the _init function (_init is at offset 0 in the file)
		push 0		; argument count
		lea ax, [position + OFFSET];
		call near ax

#endasm
		; Increment the position
		position += size;
	}
	
Instead of an _init function at a fixed offset (other than 0),
we can start the program from the top (at whatever offset the process is 
loaded at). And if the program is a driver, an initializing routine is what 
will be first. If the driver needs nothing to initialize, the first 
instruction will be a RET (Far return is not needed becuase the process will 
be loaded in the same system as the loader).

This would help in having a consistent layout for application programs as
well as drivers.

The only difference is that drivers will always run in LARGE mode (DS <>
SS), while application can optionally run in SMALL mode (DS = SS).
